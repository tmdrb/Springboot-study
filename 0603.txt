@restcontroller -> 사용자가 요청 하면 (데이터)응답
@controller -> 사용자가 요청하면 (html)응답
spring -> ioc (제어의 역전)

사용하는 이유 :
보통 경우에 우리들이 필요한 곳에서 new 를 통해서 heap 에 인스턴스를 올린다. 
그렇게 되면 불필요한 메모리 낭비가 많아지고 인스턴스 생성과 관리 하는데 신경이 쓰이게 된다.
그래서 spring이 필요한 인스턴스를 모두 생성해 주고 관리 해주겠다 
+
우리가 인스턴스를 부르게 되면 동등한 객체들이 각각 생성 되어서 메모리 낭비가 심해진다
spring 을 사용하게 되면 싱글톤 패턴으로 관리 하기 때문에 하나의 객체만 생성이 된다.
메모리 낭비가 줄어든다. 

spring 동작 방식은 component scan 을 통해서 내 패키지 밑에 있는 어노테이션이 붙어있는 객체들을 검색해서 메모리에 로드한다.
하지만 패키지 밖에 있는 객체들은 검색이 안되서 꼭 패키지 밑에 객체를 만들어야한다

! spring boot 초반에 설정하지 않고 jpa 라이브러리를 추가하게 되면 오류 발생 

.yml -> json과 비슷한 타입 , 모든 자바 설정을 할 수 있다.
.propertis 설정은 많이 사용하지 않는다. -> 적었던것을 계속 적어야 하기 때문에

git init -> git 시작하겠다  .git 디렉토리 생성 

git 개념 -> 프로젝트 관리 

MIME 

http 405 -> 해당 메소드가 허용되지 않았다.
인터넷브라우저 요청은 무조건 get 요청밖에 할 수가 없다.

post 요청은 body에 데이터를 저장해서 요청한다.

MIME 타입
<form>
<input> 
</form>   -> 이렇게 요청하는 방식이 x-www.form.urlencoded 방식

json 타입으로 보내면 @requestbody Member m 라고 하면 
MessageConveter(스프링 부트)가 매핑을 시켜서 데이터를 전달받는다.

gradle 사용 이유 -> 라이브러리 관리 편하고 , 다른환경으로 이식 용이
왜? 그냥 중앙저장소에 모여잇는 라이브러리 파일들을 setting에서 불러오기만 하면 되니까 자동으로 빌드까지 

lombok -> builder 패턴 쉽게 만들어준다. 생성자는 데이터 순서를 지켜야 하는데 builder은 순서 상관 없다. 
또한 원하는 값만 넣을수 있다.

db에서 들고온 값을 저장하는 객체는 값이 바뀌면 안되니까 final로 변수 생성

yml? -? spring 설정 (port,ip,db 등) -> key와 value 값 사이에는 반드시 공백이 필요하다.
들여쓰기 규칙은 공백 2칸

root context.xml -> 한번만 new 하는 애들 싱글톤 패턴

servlet context.xml -> 여러번 new 하는 애들 

static 폴더에서 찾는다 .jsp 는 동적파일이여서 못 찾는다 따로폴더를 만들어줘야한다. 

node js 다운후 react 설치

포트번호가 달라서 spring boot 와 cors 문제가 발생 해서 node json 파일에 가서 8080포트로 지정




0604

@GeneratedValue(strategy = GenerationType.IDENTITY) //프로젝트에서 연결된 db의 넘버링을 따라간다.

Enum 을 쓰는게 좋다.  권한에 따라 행동을 다르게 할 수 있다. 
그래서 이 권한을 String 을 이용하게 되면  다른 값들이 들어 갈 수도있다.
enum을 쓰면 내가 지정한 값(manager, admin, user) 중 하나만 들어가게 된다.

hibernate => 자바객체를 관계형데이터베이스로 매핑
  ddl-auto : [create,update,none,] ->create : 테이블을 새로 만든다 프로젝트를 실행할때마다
				         최초에만 create라고 하고 update라고 바꿔야 기존데이터를 유지할수 있따.


spring boot 에서 mongodb 접근법
1.mongoTemplate
2.mongoRepository<T,ID>

controller 에서 파라미터로 @request dto 객체를 받은 경우 mapping에서 null을 받는이유 :
mapping 되는 원리는 dto 객체에 있는 getter를 가지고 매핑을 하는데 
lombok을 사용하는 경우 get 뒤에 오는 변수의 첫번째 글자만 대문자로 만들어서 기존의 변수명과 다르다

get뒤에 오는 첫번째만 대문자로 함수를 만드는데 lombok은 아닌듯

ex)  private String aCount;
     
    intellij getter -> public String getaCount() -> 이렇게 해야 message convter가 json값을 dto 객체로 매핑시켜준다.
    lombok getter -> public String getACount() -> 이래서 변수명과 달라져서 매핑 오류

또한 lombok 는ㄴ gradle 로 추가하는것이 안되고 직접 다운로드 받아서 jar실행시켜야 한다.

Enable annotation processing은 lombok을 사용하는 프로젝트마다 설정해주어야 한다.

bulid gradle 에 
compileOnly 'org.projectlombok:lombok'
	annotationProcessor 'org.projectlombok:lombok'
추가했더니 작동

06.06
mongotemplate -> query랑 update를 이용 해서 

mongorepository -> 상속을 받아 interface를 만들고 query랑 Criteria없이 메소드로만 동작

06-08

메서드가 반환할 결과값이 ‘없음’을 명백하게 표현할 필요가 있고,
null을 반환하면 에러를 유발할 가능성이 높은 상황에서 메서드의 반환 타입으로
Optional을 사용하자는 것이 Optional을 만든 주된 목적이다.

fetch eager 전략 -> 하나의 객체에서 다른 객체를 반드시 불러와야 하는경우
ex) board table 은 user table 이 반드시 필요하다

fetch lazy 전략 -> 하나의 객체에서 다른 객체를 필요 할 때문 불러오는 경우
ex) board table 에서 reply 는 펼치기를 통해서 보고 싶을 때

interface 는 new 불가능 -> 하고 싶으면 익명객체로 만들어주어야 한다

웹 브라우저는 string 으로 data를 받아야 하는데
user라는 java object를 이해 할 수가 없다.
그래서 json 으로 변경해야한다
spring boot 는 message converter 이 응답시에 자동으로 작동한다.
자바 object를 리턴하게 되면 message converter가 Jackson 라이브러리를 호출해서
user object를 json으로 변환해서 보내준다.

06-10
update 시 null 값인 필드는 그대로 두고 받은 값만 바ㅏ꾸기
@DynamicInsert, @DynamicUpdate

@JsonInclude(JsonInclude.Include.NON_NULL)
json으로 결과 반환시 null 필드 빼고 전송

postmapping 파라미터에 @RequestBody를 사용하면 application/json 타입으로 입력받겠다는 소리
@RequestBody를 사용하지 않으면 form 타입으로 입력받겠다는 소리
이규칙을 지켜주지 않으면 error

jpa 영속성 context
data 객체를 바로 db에 전송하는 것이 아닌 entitymanager 에 저장한다.
entitymanager은 db로 전달 , entitymanager는 transaction 단위마다 수행하고 끝나면 종료한다.
transaction begin() -> flush()//db로 엔티티매니저에 있는 엔티티와 sql을 넘겨준다. -> commit() db와 엔티티매니저 동기화

그래서 save 를 하면 find를 먼저 수행하는데 db로 바로 찾아가는것이 아니라 영속성 context에 있나 확인후
db에서 값을 찾는데 이때 값을 못찾으면 insert 를 찾으면 update 를 수행한다.
jpa 는 트랜잭션이 끝나는 순간 스냅샷(가장 처음 영속된 값) 과 비교해서 변화가 생기면 저절로 update를 한다.
이걸 dirty checking 이라고한다.
이 과정에서 insert 에서는 @dynamicinsert 가 작동해서 null 값이 작성된 컬럼을 추가하지 않는다.
근데 @dynamicupdate 는 제대로 동작하지 않는다.
왜냐하면 entitymanager 에 있는 객체에서 null 을 새롭게 변경됬다고 인식 했기 때문에 null값이 주어진 컬럼도 변경하게된다.

해결법 -> entitymanager 에 있는 entity를 불러와서 set으로 필요한부분만 바꿔준다.
